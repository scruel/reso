'use client'

import { useState, useEffect } from 'react'
import { SearchBox } from './SearchBox'
import { ProductGrid } from './ProductGrid'
import { TypewriterText } from './TypewriterText'
import { Sparkles } from 'lucide-react'
import { mockThreads } from '@/data/threads'
import { Thread, SearchState } from '@/types/product'
import { shuffleArray, debounce } from '@/lib/utils'
import { initTracker } from '@/lib/tracker';
import { useInfiniteScroll } from '@/lib/useInfiniteScroll';
import { v4 as uuidv4 } from 'uuid';
import Cookies from 'js-cookie';

export function EcommerceSearch() {
  const [searchState, setSearchState] = useState<SearchState>({
    isSearching: false,
    hasSearched: false,
    query: '',
    results: []
  })
  const { items, hasMore, lastRef } = useInfiniteScroll();

  useEffect(() => {
    initTracker();
  }, []);

  const [displayThreads, setDisplayThreads] = useState<Thread[]>([])
  // Dynamic messages that change every 5 seconds
  const dynamicMessages = [
    'Based on your search for work attire that balances packability with professional style.',
    'Analyzing fashion intent for professional occasions...',
    'AI is selecting versatile blazers for work and travel.',
    'Recommending wrinkle-resistant styles based on your taste...',
  ];
  
  const [messageIndex, setMessageIndex] = useState(0);
  const [backendResponse, setBackendResponse] = useState<{
    intent: {
      title: string;
      attrs: string[];
      pic_url?: string;
    };
    message: string;
    status: number;
  } | null>(null)

// Initialize with backend products or fallback to mock threads
useEffect(() => {
  const loadInitialProducts = async () => {
    try {
      const productsResponse = await import('../lib/api').then(({ apiGet }) => 
        apiGet('/api/products')
      );
      
      if (productsResponse && productsResponse.threads && Array.isArray(productsResponse.threads)) {
        const backendThreads = productsResponse.threads.map((item: any) => ({
          id: item.id,
          good: {
            id: item.good.id,
            title: item.good.title,
            pic_url: item.good.pic_url,
            brand: item.good.brand,
            category: item.good.category,
            categoryColor: item.good.categoryColor || '#3B82F6',
            price: item.good.price
          },
          dchain: item.dchain ? {
            tbn_url: item.dchain.tbn_url,
            user_nick: item.dchain.user_nick,
            user_pic_url: item.dchain.user_pic_url
          } : undefined
        }));
        
        setDisplayThreads(shuffleArray(backendThreads));
        console.log(`üöÄ Initialized with ${backendThreads.length} products from backend`);
      } else {
        setDisplayThreads(shuffleArray(mockThreads));
        console.log('üîÑ Initialized with mock data - backend not available');
      }
    } catch (error) {
      console.error('Failed to load initial products:', error);
      setDisplayThreads(shuffleArray(mockThreads));
      console.log('üîÑ Initialized with mock data - backend error');
    }
  };
  
  loadInitialProducts();
}, [])

// Dynamic message switching every 5 seconds
useEffect(() => {
  const interval = setInterval(() => {
    setMessageIndex((prev) => (prev + 1) % dynamicMessages.length)
  }, 5000)

  return () => clearInterval(interval)
}, [])

// Update backend response message when index changes
useEffect(() => {
  if (backendResponse) {
    setBackendResponse((prev) => prev ? {
      ...prev,
      message: dynamicMessages[messageIndex],
    } : null)
  }
}, [messageIndex, backendResponse])

  // Debounced search function
  const debouncedSearch = debounce(async (query: string) => {
    setSearchState(prev => ({ ...prev, isSearching: true }))
    
    try {
      // Call real backend API for search intent
      const uuid = getUserUuid();
      const vibeResponse = await import('../lib/api').then(({ apiPost }) => 
        apiPost('/api/vibe', { uuid, query: query.trim() || 'Á≤æÈÅ∏ÂïÜÂìÅ' })
      );
      
      if (vibeResponse && vibeResponse.status === 0) {
        setBackendResponse(vibeResponse);
      }
      
      // Get products from backend
      const productsResponse = await import('../lib/api').then(({ apiGet }) => 
        apiGet('/api/products')
      );
      
      let threadsToDisplay = mockThreads; // fallback to mock data
      if (productsResponse && productsResponse.threads && Array.isArray(productsResponse.threads)) {
        // Backend format matches frontend Thread format perfectly
        threadsToDisplay = productsResponse.threads.map((item: any) => ({
          id: item.id,
          good: {
            id: item.good.id,
            title: item.good.title,
            pic_url: item.good.pic_url,
            brand: item.good.brand,
            category: item.good.category,
            categoryColor: item.good.categoryColor || '#3B82F6',
            price: item.good.price
          },
          dchain: item.dchain ? {
            tbn_url: item.dchain.tbn_url,
            user_nick: item.dchain.user_nick,
            user_pic_url: item.dchain.user_pic_url
          } : undefined
        }));
        
        console.log(`üì¶ Loaded ${threadsToDisplay.length} products from backend`);
      } else {
        console.log('‚ö†Ô∏è Using fallback mock data - backend products not available');
      }
    
    if (query.trim()) {
      // Filter threads based on query
      const filtered = threadsToDisplay.filter(thread => 
        thread.good.title.toLowerCase().includes(query.toLowerCase()) ||
        thread.good.category.toLowerCase().includes(query.toLowerCase()) ||
        thread.good.brand.toLowerCase().includes(query.toLowerCase())
      )
      
      // Simulate backend response based on query
      const mockBackendResponse = {
        intent: {
          title: query.toLowerCase().includes('jacket') || query.toLowerCase().includes('coat') 
            ? 'Â§ñÂ•óÁ≥ªÂàó' 
            : query.toLowerCase().includes('dress') 
            ? 'ÈÄ£Ë∫´Ë£ôÁ≥ªÂàó'
            : query.toLowerCase().includes('shoes') || query.toLowerCase().includes('boot')
            ? 'ÈûãÂ±•Á≥ªÂàó'
            : query.toLowerCase().includes('ÊâãÊ©ü') || query.toLowerCase().includes('phone')
            ? 'ÊâãÊ©üÁ≥ªÂàó'
            : query.toLowerCase().includes('ËÄ≥Ê©ü') || query.toLowerCase().includes('headphone')
            ? 'ËÄ≥Ê©üÁ≥ªÂàó'
            : query.toLowerCase().includes('ÈÖç‰ª∂') || query.toLowerCase().includes('keyboard')
            ? 'ÈÖç‰ª∂Á≥ªÂàó'
            : 'Á≤æÈÅ∏ÂïÜÂìÅ',
          attrs: query.toLowerCase().includes('jacket') || query.toLowerCase().includes('coat')
            ? ['‰øùÊöñ', 'Èò≤È¢®', 'ÊôÇÂ∞ö', 'Â§öÂ±§Ê¨°', 'Lightweight', 'Professional', 'Wrinkle-Resistant', 'Versatile']
            : query.toLowerCase().includes('dress')
            ? ['ÂÑ™ÈõÖ', 'ËàíÈÅ©', 'ÁôæÊê≠', 'Ê∞£Ë≥™', 'Elegant', 'Breathable', 'Flowy', 'Feminine']
            : query.toLowerCase().includes('shoes') || query.toLowerCase().includes('boot')
            ? ['ËàíÈÅ©', 'ËÄêÁ£®', 'ÊôÇÂ∞ö', 'ÈÄèÊ∞£', 'Durable', 'Non-slip', 'Cushioned', 'Flexible']
            : query.toLowerCase().includes('ÊâãÊ©ü') || query.toLowerCase().includes('phone')
            ? ['È´òÊïà', 'ÂâµÊñ∞', 'Êô∫ËÉΩ', '‰æøÊîú', 'Advanced', 'High-Performance', 'User-Friendly', 'Cutting-Edge']
            : query.toLowerCase().includes('ËÄ≥Ê©ü') || query.toLowerCase().includes('headphone')
            ? ['Èü≥Ë≥™', 'ÈôçÂô™', 'ËàíÈÅ©', 'ÁÑ°Á∑ö', 'Premium Audio', 'Noise-Cancelling', 'Wireless', 'Comfortable']
            : query.toLowerCase().includes('ÈÖç‰ª∂') || query.toLowerCase().includes('keyboard')
            ? ['ÊïàÁéá', '‰∫∫È´îÂ∑•Â≠∏', 'ÈüøÊáâ', 'ËÄêÁî®', 'Ergonomic', 'Responsive', 'Durable', 'Professional']
            : ['Á≤æÈÅ∏', 'ÂìÅË≥™', 'Ë®≠Ë®à', 'ÂØ¶Áî®', 'Premium', 'Stylish', 'Modern', 'Essential'],
          pic_url: query.toLowerCase().includes('ÊâãÊ©ü') || query.toLowerCase().includes('phone')
            ? 'https://source.unsplash.com/400x300?smartphone,technology&sig=intent1'
            : query.toLowerCase().includes('ËÄ≥Ê©ü') || query.toLowerCase().includes('headphone')
            ? 'https://source.unsplash.com/400x300?headphones,audio&sig=intent2'
            : query.toLowerCase().includes('ÈÖç‰ª∂') || query.toLowerCase().includes('keyboard')
            ? 'https://source.unsplash.com/400x300?keyboard,workspace&sig=intent3'
            : query.toLowerCase().includes('jacket') || query.toLowerCase().includes('coat')
            ? 'https://source.unsplash.com/400x300?jacket,fashion&sig=intent4'
            : 'https://source.unsplash.com/400x300?shopping,products&sig=intent5'
        },
        message: `ÁÇ∫ÊÇ®ÊâæÂà∞ ${filtered.length > 0 ? filtered.length : mockThreads.length} ÂÄãÁõ∏ÈóúÂïÜÂìÅÔºåÊ†πÊìöÊÇ®ÁöÑÊêúÂ∞ã„Äå${query}„ÄçÁÇ∫ÊÇ®Êé®Ëñ¶ÊúÄÈÅ©ÂêàÁöÑÈÅ∏Êìá„ÄÇ`,
        status: 0
      }
      
      setBackendResponse(mockBackendResponse)
      
      setSearchState(prev => ({
        ...prev,
        isSearching: false,
        hasSearched: true,
        results: shuffleArray(filtered)
      }))
      
      setDisplayThreads(shuffleArray(filtered.length > 0 ? filtered : threadsToDisplay))
    } else {
      // For empty query, show all threads from backend or fallback to mock
      setSearchState(prev => ({
        ...prev,
        isSearching: false,
        hasSearched: true,
        results: threadsToDisplay
      }))
      
      setDisplayThreads(shuffleArray(threadsToDisplay))
    }
    
    } catch (error) {
      console.error('Search error:', error);
      // Fallback to mock data and mock backend response on error
      // Show default backend response for empty queries
      const defaultBackendResponse = {
        intent: {
          title: 'Á≤æÈÅ∏ÂïÜÂìÅ',
          attrs: ['Á≤æÈÅ∏', 'ÂìÅË≥™', 'Ë®≠Ë®à', 'ÂØ¶Áî®', 'Premium', 'Curated', 'Trending', 'Best-seller'],
          pic_url: 'https://source.unsplash.com/400x300?shopping,curated&sig=default'
        },
        message: `ÁÇ∫ÊÇ®Á≤æÈÅ∏ ${mockThreads.length} ÂÄãÂÑ™Ë≥™ÂïÜÂìÅÔºåÊ∂µËìãÂêÑÁ®ÆÈ¢®Ê†ºËàáÈúÄÊ±Ç„ÄÇ`,
        status: 0
      }
      
      setBackendResponse(defaultBackendResponse)
      
      setSearchState(prev => ({
        ...prev,
        isSearching: false,
        hasSearched: true,
        results: mockThreads
      }))
      
      setDisplayThreads(shuffleArray(mockThreads))
    }
  }, 500)

  // Get or create persistent user UUID
  const getUserUuid = () => {
    const COOKIE_KEY = 'reso_user_uuid';
    let uuid = Cookies.get(COOKIE_KEY);
    
    if (!uuid) {
      uuid = uuidv4();
      // Set cookie to expire in 1 year
      Cookies.set(COOKIE_KEY, uuid, { 
        expires: 365, 
        sameSite: 'Lax',
        secure: typeof window !== 'undefined' && window.location.protocol === 'https:'
      });
    }
    
    return uuid;
  };

  // Async logging function with persistent UUID
  const logUserAction = async (actionType: string, data: any = {}) => {
    const uuid = getUserUuid();
    const query = data.query || '';
    const message = query ? `Áî®Êà∂ ${uuid} ÊêúÁ¥¢‰∫Ü "${query}"` : `Áî®Êà∂ ${uuid} Âü∑Ë°å‰∫ÜÁ©∫ÊêúÁ¥¢`;

    // Âú®console‰∏≠ÊâìÂç∞ÊêúÁ¥¢Êìç‰Ωú
    console.log(`üîç ${message}`);

    try {
      import('../lib/api').then(({ getApiUrl }) => {
        fetch(getApiUrl('/api/vibe'), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ uuid, query }),
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.status === 0) {
              setBackendResponse(data);
            }
          })
          .catch(() => {/* silent */});
      });
      
      return uuid;
    } catch (error) {
      return null;
    }
  };

  const handleSearch = (query: string) => {
    setSearchState(prev => ({ ...prev, query, hasSearched: true }))
    debouncedSearch(query);
  
    // Log search action with UUID asynchronously
    logUserAction('search', {
      query,
      searchType: query.trim() ? 'text_search' : 'empty_search'
    });
  }
  

  const handleReset = () => {
    setSearchState({
      isSearching: false,
      hasSearched: false,
      query: '',
      results: []
    })
    // Keep backend response visible after reset
    const defaultBackendResponse = {
      intent: {
        title: 'Á≤æÈÅ∏ÂïÜÂìÅ',
        attrs: ['Á≤æÈÅ∏', 'ÂìÅË≥™', 'Ë®≠Ë®à', 'ÂØ¶Áî®', 'Premium', 'Curated', 'Trending', 'Best-seller'],
        pic_url: 'https://source.unsplash.com/400x300?shopping,curated&sig=default'
      },
      message: `ÁÇ∫ÊÇ®Á≤æÈÅ∏ ${mockThreads.length} ÂÄãÂÑ™Ë≥™ÂïÜÂìÅÔºåÊ∂µËìãÂêÑÁ®ÆÈ¢®Ê†ºËàáÈúÄÊ±Ç„ÄÇ`,
      status: 0
    }
    setBackendResponse(defaultBackendResponse)
    setDisplayThreads(shuffleArray(mockThreads))
  }

  return (
    <>
      {/* Light Blue Top Navigation Bar - Separate from page content */}
      <div className="fixed top-0 left-0 right-0 z-50 bg-sky-500 h-12 flex items-center">
        <div className="container mx-auto px-4">
          <div className="text-white text-xl font-medium tracking-wide">
            Reso
          </div>
        </div>
      </div>

      {/* Main Page Content */}
      <div className="relative min-h-screen z-20 pt-12">
        {/* Background with subtle pattern */}
        <div className="absolute inset-0 bg-gray-100" />
      
      {/* Hero section with branding */}
      {!searchState.hasSearched && (
        <div className="relative z-10 pt-32 pb-32 text-center">
          <div className="animate-fade-in">
            <h1 className="text-5xl md:text-6xl font-light text-gray-900 mb-4 tracking-tight">
              RESO
            </h1>
            <p className="text-xl md:text-2xl text-gray-600 mb-12 font-light">
              Áî± AI Á≠ñÂäÉÁöÑÁèæ‰ª£Ë≥ºÁâ©È´îÈ©ó
            </p>
          </div>
        </div>
      )}
      
      {/* Search Box */}
      <div>
        <SearchBox
          onSearch={handleSearch}
          onReset={handleReset}
          isSearching={searchState.isSearching}
          hasSearched={searchState.hasSearched}
          query={searchState.query}
        />
      </div>
      
      {/* Backend Response Display */}
      {backendResponse && searchState.hasSearched && (
        <div className="relative z-20 mt-4">
          <div className="container mx-auto px-4">
            <div className="flex justify-between items-start gap-6 py-8 flex-wrap">
              {/* Â∑¶ÂçÄÔºöTitle Âíå Tags Ê∞¥Âπ≥ÊéíÂàó */}
              <div className="w-full max-w-[60%] flex items-start gap-4">
                {/* Title ËÉåÊôØÂç°Áâá - Ë≤ºÂêàÂÖßÂÆπÂ§ßÂ∞è */}
                <div className="bg-white p-4 rounded-2xl shadow-sm flex items-center gap-3 w-fit flex-shrink-0">
                  {backendResponse.intent.pic_url ? (
                    <div className="w-12 h-12 rounded-lg overflow-hidden flex-shrink-0">
                      <img 
                        src={backendResponse.intent.pic_url} 
                        alt={backendResponse.intent.title}
                        className="w-full h-full object-cover"
                      />
                    </div>
                  ) : (
                    <div className="w-12 h-12 flex items-center justify-center text-3xl">üß•</div>
                  )}
                  <h1 className="text-2xl font-bold text-gray-800">{backendResponse.intent.title}</h1>
                </div>

                {/* Tags Ê∞¥Âπ≥ÊéíÂàó‰∏¶Ëá™ÂãïÊèõË°åÔºåÊúÄÂ§öÈ°ØÁ§∫‰∏âË°å */}
                <div className="flex flex-wrap gap-1.5 items-start max-h-[4.5rem] overflow-hidden relative flex-1">
                  {backendResponse.intent.attrs.map((tag, i) => (
                    <span
                      key={i}
                      className="bg-white text-gray-700 text-xs px-2 py-0.5 rounded border border-gray-200 whitespace-nowrap"
                    >
                      {tag}
                    </span>
                  ))}
                  {/* ÁúÅÁï•ËôüÊåáÁ§∫Âô®ÔºåÁï∂ÂÖßÂÆπË∂ÖÂá∫ÊôÇÈ°ØÁ§∫ */}
                  <div className="absolute bottom-0 right-0 bg-gradient-to-l from-gray-50 via-gray-50 to-transparent pl-8 text-gray-500 text-xs">
                    {backendResponse.intent.attrs.length > 12 && '...'}
                  </div>
                </div>
              </div>

              {/* Âè≥ÂçÄÔºöAI message ÂçÄÂ°ä */}
              <div className="bg-white p-4 rounded-2xl shadow-sm max-w-[35%] min-w-[280px] text-sm text-gray-700 leading-relaxed flex gap-2">
                <span className="text-sky-500 text-xl">‚ú®</span>
                <p>
                  <strong>{dynamicMessages[messageIndex]}</strong><br />
                  {backendResponse.message}
                </p>
              </div>
            </div>
          </div>
        </div>
      )}
        {/* Products Grid */}
        {searchState.hasSearched && (
          <div className="relative z-10 pt-2 pb-8">
            <div className="container mx-auto px-4">
              
              <ProductGrid 
                products={displayThreads} 
                isLoading={searchState.isSearching}
                searchQuery={searchState.query}
              />
            </div>
          </div>
        )}
        
        {/* Bottom fade overlay for dreamy effect */}
        <div className="fixed bottom-0 left-0 right-0 h-24 pointer-events-none z-30 bg-gradient-to-t from-gray-100 via-gray-100/60 to-transparent" />
        
      </div>
    </>
  )
}
